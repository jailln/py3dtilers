<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.Common.group API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.Common.group</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from os import listdir
import json
from shapely.geometry import Point, Polygon
from ..Common import ObjectsToTile
from ..Common import kd_tree


class Group():
    &#34;&#34;&#34;
    Contains an instance of ObjectsToTile
    It can also contain additional polygon points (used to create LOA nodes)
    &#34;&#34;&#34;

    def __init__(self, objects_to_tile, with_polygon=False, additional_points=list(), points_dict=dict()):
        self.objects_to_tile = objects_to_tile
        self.with_polygon = with_polygon
        self.additional_points = additional_points
        self.points_dict = points_dict

    def get_centroid(self):
        return self.objects_to_tile.get_centroid()

    def round_coordinates(self, coordinates, base):
        rounded_coord = coordinates
        for i in range(0, len(coordinates)):
            rounded_coord[i] = base * round(coordinates[i] / base)
        return rounded_coord


class Groups():
    &#34;&#34;&#34;
    Contains a list of Group
    &#34;&#34;&#34;

    def __init__(self, objects_to_tile, polygons_path=None):
        &#34;&#34;&#34;
        Distribute the geometries contained in objects_to_tile into different Group
        The way to distribute the geometries depends on the parameters
        :param objects_to_tile: an instance of ObjectsToTile containing a list of geometries to distribute into Group
        :param polygons_path: the path to a folder containing polygons as .geojson files.
        When this param is not None, it means we want to group geometries by polygons
        &#34;&#34;&#34;
        self.objects_to_tile = objects_to_tile
        if objects_to_tile.is_list_of_objects_to_tile():
            self.group_objects_by_instance()
        elif polygons_path is not None:
            self.group_objects_by_polygons(polygons_path)
        else:
            self.group_objects_with_kdtree()

    def get_groups_as_list(self):
        return self.groups

    def group_objects_by_instance(self):
        groups = list()
        for objects in self.objects_to_tile:
            group = Group(objects)
            groups.append(group)
        self.groups = groups

    def group_objects_with_kdtree(self):
        groups = list()
        objects = kd_tree(self.objects_to_tile, 500)
        for objects_to_tile in objects:
            group = Group(objects_to_tile)
            groups.append(group)
        self.groups = groups

    def group_objects_by_polygons(self, polygons_path):
        &#34;&#34;&#34;
        Load the polygons from the files in the folder
        :param polygons_path: the path of the folder containing the files
        &#34;&#34;&#34;
        polygons = list()
        files = []

        if(os.path.isdir(polygons_path)):
            geojson_dir = listdir(polygons_path)
            for geojson_file in geojson_dir:
                file_path = os.path.join(polygons_path, geojson_file)
                if(os.path.isfile(file_path)):
                    files.append(file_path)
        else:
            files.append(polygons_path)

        # Read all the polygons in the file(s)
        for file in files:
            if(&#34;.geojson&#34; in file or &#34;.json&#34; in file):
                with open(file) as f:
                    gjContent = json.load(f)
                for feature in gjContent[&#39;features&#39;]:
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;Polygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][:-1]
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;MultiPolygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][0][:-1]
                    polygons.append(Polygon(coords))
        self.groups = self.distribute_objects_in_polygons(polygons)

    def distribute_objects_in_polygons(self, polygons):
        &#34;&#34;&#34;
        Distribute the geometries in the polygons.
        The geometries in the same polygon are grouped together. The Group created will also contain the points of the polygon.
        If a geometry is not in any polygon, create a Group containing only this geometry. This group won&#39;t have addtional points.
        &#34;&#34;&#34;

        objects_to_tile = self.objects_to_tile
        objects_to_tile_dict = {}
        objects_to_tile_without_poly = {}

        # For each geometry, find the polygon containing it
        for i, object_to_tile in enumerate(objects_to_tile):
            p = Point(object_to_tile.get_centroid())
            in_polygon = False
            for index, polygon in enumerate(polygons):
                if p.within(polygon):
                    if index in objects_to_tile_dict:
                        objects_to_tile_dict[index].append(i)
                    else:
                        objects_to_tile_dict[index] = [i]
                    in_polygon = True
                    break
            if not in_polygon:
                objects_to_tile_without_poly[i] = [i]

        # Create a list of Group
        groups = list()
        for key in objects_to_tile_dict:
            additional_points = polygons[key].exterior.coords[:-1]
            contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_dict[key]])
            group = Group(contained_objects, with_polygon=True, additional_points=additional_points)
            groups.append(group)
        for key in objects_to_tile_without_poly:
            contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_without_poly[key]])
            group = Group(contained_objects)
            groups.append(group)

        return self.distribute_groups_in_cubes(groups, 300)

    def distribute_groups_in_cubes(self, groups, cube_size=300):
        &#34;&#34;&#34;
        Merges together the groups in order to reduce the number of tiles.
        The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
        To avoid conflicts, the groups with a polygon are not merged with those without polygon.
        &#34;&#34;&#34;
        groups_dict = {}

        # Create a dictionary key: cubes center (x,y,z), with geometry (boolean); value: list of groups index
        for i in range(0, len(groups)):
            closest_cube = groups[i].round_coordinates(groups[i].get_centroid(), cube_size)
            with_polygon = groups[i].with_polygon
            if (tuple(closest_cube), with_polygon) in groups_dict:
                groups_dict[(tuple(closest_cube), with_polygon)].append(i)
            else:
                groups_dict[(tuple(closest_cube), with_polygon)] = [i]

        # Merge the groups in the same cube and create new groups
        groups_in_cube = list()
        for cube in groups_dict:
            with_polygon = cube[1]
            groups_in_cube.append(self.merge_groups_together(groups, groups_dict[cube], with_polygon))

        return groups_in_cube

    def merge_groups_together(self, groups, group_indexes, with_polygon):
        &#34;&#34;&#34;
        Creates a Group from a list of Groups
        &#34;&#34;&#34;

        objects = list()
        additional_points_list = list()
        additional_points_dict = dict()

        for index in group_indexes:
            if with_polygon:
                additional_points_list.append(groups[index].additional_points)
                points_index = len(additional_points_list) - 1
                additional_points_dict[points_index] = []
                for object_to_tile in groups[index].objects_to_tile:
                    objects.append(object_to_tile)
                    additional_points_dict[points_index].append(len(objects) - 1)
            else:
                for object_to_tile in groups[index].objects_to_tile:
                    objects.append(object_to_tile)
        return Group(ObjectsToTile(objects), with_polygon=with_polygon, additional_points=additional_points_list, points_dict=additional_points_dict)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.Common.group.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
<span>(</span><span>objects_to_tile, with_polygon=False, additional_points=[], points_dict={})</span>
</code></dt>
<dd>
<div class="desc"><p>Contains an instance of ObjectsToTile
It can also contain additional polygon points (used to create LOA nodes)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group():
    &#34;&#34;&#34;
    Contains an instance of ObjectsToTile
    It can also contain additional polygon points (used to create LOA nodes)
    &#34;&#34;&#34;

    def __init__(self, objects_to_tile, with_polygon=False, additional_points=list(), points_dict=dict()):
        self.objects_to_tile = objects_to_tile
        self.with_polygon = with_polygon
        self.additional_points = additional_points
        self.points_dict = points_dict

    def get_centroid(self):
        return self.objects_to_tile.get_centroid()

    def round_coordinates(self, coordinates, base):
        rounded_coord = coordinates
        for i in range(0, len(coordinates)):
            rounded_coord[i] = base * round(coordinates[i] / base)
        return rounded_coord</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.group.Group.get_centroid"><code class="name flex">
<span>def <span class="ident">get_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroid(self):
    return self.objects_to_tile.get_centroid()</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Group.round_coordinates"><code class="name flex">
<span>def <span class="ident">round_coordinates</span></span>(<span>self, coordinates, base)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_coordinates(self, coordinates, base):
    rounded_coord = coordinates
    for i in range(0, len(coordinates)):
        rounded_coord[i] = base * round(coordinates[i] / base)
    return rounded_coord</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.Common.group.Groups"><code class="flex name class">
<span>class <span class="ident">Groups</span></span>
<span>(</span><span>objects_to_tile, polygons_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a list of Group</p>
<p>Distribute the geometries contained in objects_to_tile into different Group
The way to distribute the geometries depends on the parameters
:param objects_to_tile: an instance of ObjectsToTile containing a list of geometries to distribute into Group
:param polygons_path: the path to a folder containing polygons as .geojson files.
When this param is not None, it means we want to group geometries by polygons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Groups():
    &#34;&#34;&#34;
    Contains a list of Group
    &#34;&#34;&#34;

    def __init__(self, objects_to_tile, polygons_path=None):
        &#34;&#34;&#34;
        Distribute the geometries contained in objects_to_tile into different Group
        The way to distribute the geometries depends on the parameters
        :param objects_to_tile: an instance of ObjectsToTile containing a list of geometries to distribute into Group
        :param polygons_path: the path to a folder containing polygons as .geojson files.
        When this param is not None, it means we want to group geometries by polygons
        &#34;&#34;&#34;
        self.objects_to_tile = objects_to_tile
        if objects_to_tile.is_list_of_objects_to_tile():
            self.group_objects_by_instance()
        elif polygons_path is not None:
            self.group_objects_by_polygons(polygons_path)
        else:
            self.group_objects_with_kdtree()

    def get_groups_as_list(self):
        return self.groups

    def group_objects_by_instance(self):
        groups = list()
        for objects in self.objects_to_tile:
            group = Group(objects)
            groups.append(group)
        self.groups = groups

    def group_objects_with_kdtree(self):
        groups = list()
        objects = kd_tree(self.objects_to_tile, 500)
        for objects_to_tile in objects:
            group = Group(objects_to_tile)
            groups.append(group)
        self.groups = groups

    def group_objects_by_polygons(self, polygons_path):
        &#34;&#34;&#34;
        Load the polygons from the files in the folder
        :param polygons_path: the path of the folder containing the files
        &#34;&#34;&#34;
        polygons = list()
        files = []

        if(os.path.isdir(polygons_path)):
            geojson_dir = listdir(polygons_path)
            for geojson_file in geojson_dir:
                file_path = os.path.join(polygons_path, geojson_file)
                if(os.path.isfile(file_path)):
                    files.append(file_path)
        else:
            files.append(polygons_path)

        # Read all the polygons in the file(s)
        for file in files:
            if(&#34;.geojson&#34; in file or &#34;.json&#34; in file):
                with open(file) as f:
                    gjContent = json.load(f)
                for feature in gjContent[&#39;features&#39;]:
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;Polygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][:-1]
                    if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;MultiPolygon&#39;:
                        coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][0][:-1]
                    polygons.append(Polygon(coords))
        self.groups = self.distribute_objects_in_polygons(polygons)

    def distribute_objects_in_polygons(self, polygons):
        &#34;&#34;&#34;
        Distribute the geometries in the polygons.
        The geometries in the same polygon are grouped together. The Group created will also contain the points of the polygon.
        If a geometry is not in any polygon, create a Group containing only this geometry. This group won&#39;t have addtional points.
        &#34;&#34;&#34;

        objects_to_tile = self.objects_to_tile
        objects_to_tile_dict = {}
        objects_to_tile_without_poly = {}

        # For each geometry, find the polygon containing it
        for i, object_to_tile in enumerate(objects_to_tile):
            p = Point(object_to_tile.get_centroid())
            in_polygon = False
            for index, polygon in enumerate(polygons):
                if p.within(polygon):
                    if index in objects_to_tile_dict:
                        objects_to_tile_dict[index].append(i)
                    else:
                        objects_to_tile_dict[index] = [i]
                    in_polygon = True
                    break
            if not in_polygon:
                objects_to_tile_without_poly[i] = [i]

        # Create a list of Group
        groups = list()
        for key in objects_to_tile_dict:
            additional_points = polygons[key].exterior.coords[:-1]
            contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_dict[key]])
            group = Group(contained_objects, with_polygon=True, additional_points=additional_points)
            groups.append(group)
        for key in objects_to_tile_without_poly:
            contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_without_poly[key]])
            group = Group(contained_objects)
            groups.append(group)

        return self.distribute_groups_in_cubes(groups, 300)

    def distribute_groups_in_cubes(self, groups, cube_size=300):
        &#34;&#34;&#34;
        Merges together the groups in order to reduce the number of tiles.
        The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
        To avoid conflicts, the groups with a polygon are not merged with those without polygon.
        &#34;&#34;&#34;
        groups_dict = {}

        # Create a dictionary key: cubes center (x,y,z), with geometry (boolean); value: list of groups index
        for i in range(0, len(groups)):
            closest_cube = groups[i].round_coordinates(groups[i].get_centroid(), cube_size)
            with_polygon = groups[i].with_polygon
            if (tuple(closest_cube), with_polygon) in groups_dict:
                groups_dict[(tuple(closest_cube), with_polygon)].append(i)
            else:
                groups_dict[(tuple(closest_cube), with_polygon)] = [i]

        # Merge the groups in the same cube and create new groups
        groups_in_cube = list()
        for cube in groups_dict:
            with_polygon = cube[1]
            groups_in_cube.append(self.merge_groups_together(groups, groups_dict[cube], with_polygon))

        return groups_in_cube

    def merge_groups_together(self, groups, group_indexes, with_polygon):
        &#34;&#34;&#34;
        Creates a Group from a list of Groups
        &#34;&#34;&#34;

        objects = list()
        additional_points_list = list()
        additional_points_dict = dict()

        for index in group_indexes:
            if with_polygon:
                additional_points_list.append(groups[index].additional_points)
                points_index = len(additional_points_list) - 1
                additional_points_dict[points_index] = []
                for object_to_tile in groups[index].objects_to_tile:
                    objects.append(object_to_tile)
                    additional_points_dict[points_index].append(len(objects) - 1)
            else:
                for object_to_tile in groups[index].objects_to_tile:
                    objects.append(object_to_tile)
        return Group(ObjectsToTile(objects), with_polygon=with_polygon, additional_points=additional_points_list, points_dict=additional_points_dict)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.Common.group.Groups.distribute_groups_in_cubes"><code class="name flex">
<span>def <span class="ident">distribute_groups_in_cubes</span></span>(<span>self, groups, cube_size=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Merges together the groups in order to reduce the number of tiles.
The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
To avoid conflicts, the groups with a polygon are not merged with those without polygon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute_groups_in_cubes(self, groups, cube_size=300):
    &#34;&#34;&#34;
    Merges together the groups in order to reduce the number of tiles.
    The groups are distributed into cubes of a grid. The groups in the same cube are merged together.
    To avoid conflicts, the groups with a polygon are not merged with those without polygon.
    &#34;&#34;&#34;
    groups_dict = {}

    # Create a dictionary key: cubes center (x,y,z), with geometry (boolean); value: list of groups index
    for i in range(0, len(groups)):
        closest_cube = groups[i].round_coordinates(groups[i].get_centroid(), cube_size)
        with_polygon = groups[i].with_polygon
        if (tuple(closest_cube), with_polygon) in groups_dict:
            groups_dict[(tuple(closest_cube), with_polygon)].append(i)
        else:
            groups_dict[(tuple(closest_cube), with_polygon)] = [i]

    # Merge the groups in the same cube and create new groups
    groups_in_cube = list()
    for cube in groups_dict:
        with_polygon = cube[1]
        groups_in_cube.append(self.merge_groups_together(groups, groups_dict[cube], with_polygon))

    return groups_in_cube</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.distribute_objects_in_polygons"><code class="name flex">
<span>def <span class="ident">distribute_objects_in_polygons</span></span>(<span>self, polygons)</span>
</code></dt>
<dd>
<div class="desc"><p>Distribute the geometries in the polygons.
The geometries in the same polygon are grouped together. The Group created will also contain the points of the polygon.
If a geometry is not in any polygon, create a Group containing only this geometry. This group won't have addtional points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute_objects_in_polygons(self, polygons):
    &#34;&#34;&#34;
    Distribute the geometries in the polygons.
    The geometries in the same polygon are grouped together. The Group created will also contain the points of the polygon.
    If a geometry is not in any polygon, create a Group containing only this geometry. This group won&#39;t have addtional points.
    &#34;&#34;&#34;

    objects_to_tile = self.objects_to_tile
    objects_to_tile_dict = {}
    objects_to_tile_without_poly = {}

    # For each geometry, find the polygon containing it
    for i, object_to_tile in enumerate(objects_to_tile):
        p = Point(object_to_tile.get_centroid())
        in_polygon = False
        for index, polygon in enumerate(polygons):
            if p.within(polygon):
                if index in objects_to_tile_dict:
                    objects_to_tile_dict[index].append(i)
                else:
                    objects_to_tile_dict[index] = [i]
                in_polygon = True
                break
        if not in_polygon:
            objects_to_tile_without_poly[i] = [i]

    # Create a list of Group
    groups = list()
    for key in objects_to_tile_dict:
        additional_points = polygons[key].exterior.coords[:-1]
        contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_dict[key]])
        group = Group(contained_objects, with_polygon=True, additional_points=additional_points)
        groups.append(group)
    for key in objects_to_tile_without_poly:
        contained_objects = ObjectsToTile([objects_to_tile[i] for i in objects_to_tile_without_poly[key]])
        group = Group(contained_objects)
        groups.append(group)

    return self.distribute_groups_in_cubes(groups, 300)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.get_groups_as_list"><code class="name flex">
<span>def <span class="ident">get_groups_as_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_groups_as_list(self):
    return self.groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.group_objects_by_instance"><code class="name flex">
<span>def <span class="ident">group_objects_by_instance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_by_instance(self):
    groups = list()
    for objects in self.objects_to_tile:
        group = Group(objects)
        groups.append(group)
    self.groups = groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.group_objects_by_polygons"><code class="name flex">
<span>def <span class="ident">group_objects_by_polygons</span></span>(<span>self, polygons_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the polygons from the files in the folder
:param polygons_path: the path of the folder containing the files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_by_polygons(self, polygons_path):
    &#34;&#34;&#34;
    Load the polygons from the files in the folder
    :param polygons_path: the path of the folder containing the files
    &#34;&#34;&#34;
    polygons = list()
    files = []

    if(os.path.isdir(polygons_path)):
        geojson_dir = listdir(polygons_path)
        for geojson_file in geojson_dir:
            file_path = os.path.join(polygons_path, geojson_file)
            if(os.path.isfile(file_path)):
                files.append(file_path)
    else:
        files.append(polygons_path)

    # Read all the polygons in the file(s)
    for file in files:
        if(&#34;.geojson&#34; in file or &#34;.json&#34; in file):
            with open(file) as f:
                gjContent = json.load(f)
            for feature in gjContent[&#39;features&#39;]:
                if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;Polygon&#39;:
                    coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][:-1]
                if feature[&#39;geometry&#39;][&#39;type&#39;] == &#39;MultiPolygon&#39;:
                    coords = feature[&#39;geometry&#39;][&#39;coordinates&#39;][0][0][:-1]
                polygons.append(Polygon(coords))
    self.groups = self.distribute_objects_in_polygons(polygons)</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.group_objects_with_kdtree"><code class="name flex">
<span>def <span class="ident">group_objects_with_kdtree</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_objects_with_kdtree(self):
    groups = list()
    objects = kd_tree(self.objects_to_tile, 500)
    for objects_to_tile in objects:
        group = Group(objects_to_tile)
        groups.append(group)
    self.groups = groups</code></pre>
</details>
</dd>
<dt id="py3dtilers.Common.group.Groups.merge_groups_together"><code class="name flex">
<span>def <span class="ident">merge_groups_together</span></span>(<span>self, groups, group_indexes, with_polygon)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Group from a list of Groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_groups_together(self, groups, group_indexes, with_polygon):
    &#34;&#34;&#34;
    Creates a Group from a list of Groups
    &#34;&#34;&#34;

    objects = list()
    additional_points_list = list()
    additional_points_dict = dict()

    for index in group_indexes:
        if with_polygon:
            additional_points_list.append(groups[index].additional_points)
            points_index = len(additional_points_list) - 1
            additional_points_dict[points_index] = []
            for object_to_tile in groups[index].objects_to_tile:
                objects.append(object_to_tile)
                additional_points_dict[points_index].append(len(objects) - 1)
        else:
            for object_to_tile in groups[index].objects_to_tile:
                objects.append(object_to_tile)
    return Group(ObjectsToTile(objects), with_polygon=with_polygon, additional_points=additional_points_list, points_dict=additional_points_dict)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers.Common" href="index.html">py3dtilers.Common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.Common.group.Group" href="#py3dtilers.Common.group.Group">Group</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.group.Group.get_centroid" href="#py3dtilers.Common.group.Group.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.group.Group.round_coordinates" href="#py3dtilers.Common.group.Group.round_coordinates">round_coordinates</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.Common.group.Groups" href="#py3dtilers.Common.group.Groups">Groups</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.group.Groups.distribute_groups_in_cubes" href="#py3dtilers.Common.group.Groups.distribute_groups_in_cubes">distribute_groups_in_cubes</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.distribute_objects_in_polygons" href="#py3dtilers.Common.group.Groups.distribute_objects_in_polygons">distribute_objects_in_polygons</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.get_groups_as_list" href="#py3dtilers.Common.group.Groups.get_groups_as_list">get_groups_as_list</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.group_objects_by_instance" href="#py3dtilers.Common.group.Groups.group_objects_by_instance">group_objects_by_instance</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.group_objects_by_polygons" href="#py3dtilers.Common.group.Groups.group_objects_by_polygons">group_objects_by_polygons</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.group_objects_with_kdtree" href="#py3dtilers.Common.group.Groups.group_objects_with_kdtree">group_objects_with_kdtree</a></code></li>
<li><code><a title="py3dtilers.Common.group.Groups.merge_groups_together" href="#py3dtilers.Common.group.Groups.merge_groups_together">merge_groups_together</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>