<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.IfcTiler.ifcObjectGeom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.IfcTiler.ifcObjectGeom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
import sys
import math
import numpy as np
import ifcopenshell
from ..Common import ObjectToTile, ObjectsToTile


def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm


def computeDirection(axis, refDirection):
    # ref to https://standards.buildingsmart.org/IFC/RELEASE/IFC2x3/FINAL/HTML/ifcgeometryresource/lexical/ifcfirstprojaxis.htm
    # and https://standards.buildingsmart.org/IFC/RELEASE/IFC2x3/FINAL/HTML/ifcgeometryresource/lexical/ifcbuildaxes.htm
    Z = normalize(axis)
    V = normalize(refDirection)
    XVec = np.multiply(np.dot(V, Z), Z)
    XAxis = normalize(np.subtract(V, XVec))
    return np.array([XAxis, np.cross(Z, XAxis), Z])


def compute2DDirection(refDirection):
    return np.array([np.array([refDirection[0], refDirection[1]]), np.array([-refDirection[1], refDirection[0]])])


def unitConversion(originalUnit, targetedUnit):
    conversions = {
        &#34;mm&#34;: {&#34;mm&#34;: 1, &#34;cm&#34;: 1 / 10, &#34;m&#34;: 1 / 1000, &#34;km&#34;: 1 / 1000000},
        &#34;cm&#34;: {&#34;mm&#34;: 10, &#34;cm&#34;: 1, &#34;m&#34;: 1 / 100, &#34;km&#34;: 1 / 100000},
        &#34;m&#34;: {&#34;mm&#34;: 1000, &#34;cm&#34;: 100, &#34;m&#34;: 1, &#34;km&#34;: 1 / 1000},
        &#34;km&#34;: {&#34;mm&#34;: 100000, &#34;cm&#34;: 10000, &#34;m&#34;: 1000, &#34;km&#34;: 1},
    }
    return conversions[originalUnit][targetedUnit]


class IfcObjectGeom(ObjectToTile):
    def __init__(self, ifcObject, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;, transform_matrix=None, ifcGroup=None):
        super().__init__(ifcObject.GlobalId)

        self.ifcObject = ifcObject
        self.setIfcClasse(ifcObject.is_a(), ifcGroup)
        self.convertionRatio = unitConversion(originalUnit, targetedUnit)
        self.has_geom = self.parse_geom(transform_matrix)

    def hasGeom(self):
        return self.has_geom

    def get_geom_as_triangles(self):
        return self.geom.triangles[0]

    def set_triangles(self, triangles):
        self.geom.triangles[0] = triangles

    def computeCenter(self, pointList):
        center = np.array([0.0, 0.0, 0.0])
        for point in pointList:
            center += np.array([point[0], point[1], 0])
        return center / len(pointList)

    def setIfcClasse(self, ifcClasse, ifcGroup):
        self.ifcClasse = ifcClasse
        batch_table_data = {
            &#39;classe&#39;: ifcClasse,
            &#39;group&#39;: ifcGroup
        }
        super().set_batchtable_data(batch_table_data)

    def getIfcClasse(self):
        return self.ifcClasse

    def computePointsFromRectangleProfileDef(self, sweptArea):
        points = list()
        maxX = sweptArea.XDim / 2
        minX = -maxX
        maxY = sweptArea.YDim / 2
        minY = -maxY

        position = sweptArea.Position.Location.Coordinates

        refDirection = [1, 0]

        if (sweptArea.Position.RefDirection):
            refDirection = sweptArea.Position.RefDirection.DirectionRatios

        direction = compute2DDirection(refDirection)

        points.append(np.array([minX, minY]))
        points.append(np.array([minX, maxY]))
        points.append(np.array([maxX, maxY]))
        points.append(np.array([maxX, minY]))
        points.append(points[0])

        for i in range(len(points)):
            points[i] = np.dot(np.array(points[i]), direction) + position
        return points

    def computePointsFromCircleProfileDef(self, sweptArea):
        radius = sweptArea.Radius
        position = sweptArea.Position.Location.Coordinates

        refDirection = [1, 0]

        if (sweptArea.Position.RefDirection):
            refDirection = sweptArea.Position.RefDirection.DirectionRatios

        direction = compute2DDirection(refDirection)

        points = list()
        # The lower this value the higher quality the circle is with more points generated
        stepSize = 0.1
        t = 0
        while t &lt; 2 * math.pi:
            points.append(np.array([radius * math.cos(t), radius * math.sin(t)]))
            t += stepSize
        points.append(points[0])

        for i in range(len(points)):
            points[i] = np.dot(np.array(points[i]), direction) + position
        return points

    def getPointsFromOuterCurve(self, outerCurve):
        if(hasattr(outerCurve, &#39;CoordList&#39;)):
            return outerCurve.CoordList
        else:
            points = list()
            for point in outerCurve:
                coord = point.Coordinates
                points.append(np.array([coord[0], coord[1]]))
            return points

    def extrudGeom(self, geom):
        depth = geom.Depth
        extrudedDirection = geom.ExtrudedDirection.DirectionRatios
        extrudVector = np.multiply(extrudedDirection, depth)

        position = geom.Position.Location.Coordinates

        axis = [0, 0, 1]
        refDirection = [1, 0, 0]

        if (geom.Position.Axis):
            axis = geom.Position.Axis.DirectionRatios

        if (geom.Position.RefDirection):
            refDirection = geom.Position.RefDirection.DirectionRatios

        direction = computeDirection(axis, refDirection)

        if(geom.SweptArea.is_a(&#39;IfcArbitraryClosedProfileDef&#39;)):
            if(hasattr(geom.SweptArea.OuterCurve, &#34;Points&#34;)):
                points = self.getPointsFromOuterCurve(geom.SweptArea.OuterCurve.Points)
            else:
                return None, None
        elif(geom.SweptArea.is_a(&#39;IfcRectangleProfileDef&#39;)):
            points = self.computePointsFromRectangleProfileDef(geom.SweptArea)
        elif(geom.SweptArea.is_a(&#39;IfcCircleProfileDef&#39;)):
            points = self.computePointsFromCircleProfileDef(geom.SweptArea)
        else:
            return None, None

        center = self.computeCenter(points)

        vertexList = list()
        indexList = list()
        for point in points:
            vertexList.append(np.array([point[0], point[1], 0]))
        for point in points:
            vertexList.append(np.array([point[0], point[1], 0]) + extrudVector)
        vertexList.append(center)
        vertexList.append(center + extrudVector)

        for i in range(len(vertexList)):
            vertexList[i] = np.dot(np.array(vertexList[i]), direction) + position

        nb_points = len(points)
        i = 0
        for i in range(nb_points - 1):
            indice = i + 1
            indexList.append([indice, (nb_points * 2) + 1, indice + 1])
            indexList.append([indice + nb_points, indice + nb_points + 1, (nb_points * 2) + 2])

        i = 0
        for i in range(nb_points - 1):
            indice = i + 1
            indexList.append([indice, indice + 1, indice + nb_points])
            indexList.append([indice + 1, indice + nb_points + 1, indice + nb_points])

        return vertexList, indexList

    def getPosition(self, ObjectPlacement):
        listPosition = list()
        position = np.array(ObjectPlacement.RelativePlacement.Location.Coordinates)
        listPosition.append(position)
        placementRelTo = ObjectPlacement.PlacementRelTo

        while (placementRelTo):
            if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
                break
            listPosition.append(np.array(placementRelTo.RelativePlacement.Location.Coordinates))
            placementRelTo = placementRelTo.PlacementRelTo
        return listPosition

    def getDirections(self, ObjectPlacement):
        listDirection = list()
        axis = [0, 0, 1]
        if (ObjectPlacement.RelativePlacement.Axis):
            axis = ObjectPlacement.RelativePlacement.Axis.DirectionRatios

        refDirection = [1, 0, 0]
        if (ObjectPlacement.RelativePlacement.RefDirection):
            refDirection = ObjectPlacement.RelativePlacement.RefDirection.DirectionRatios

        listDirection.append(computeDirection(axis, refDirection))

        placementRelTo = ObjectPlacement.PlacementRelTo

        while (placementRelTo):
            if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
                break
            axis = [0, 0, 1]
            if (placementRelTo.RelativePlacement.Axis):
                axis = placementRelTo.RelativePlacement.Axis.DirectionRatios

            refDirection = [1, 0, 0]
            if (placementRelTo.RelativePlacement.RefDirection):
                refDirection = placementRelTo.RelativePlacement.RefDirection.DirectionRatios

            listDirection.append(computeDirection(axis, refDirection))
            placementRelTo = placementRelTo.PlacementRelTo

        return listDirection

    def getElevation(self):
        elevation = 0
        if(self.ifcObject.ContainedInStructure):
            if(not(self.ifcObject.ContainedInStructure[0].RelatingStructure.is_a(&#34;IfcSpace&#34;))):
                elevation += (self.ifcObject.ContainedInStructure[0].RelatingStructure.Elevation * self.convertionRatio)
        return elevation

    def parse_indexed_faces(self, Faces):
        indexListTemp = list()

        for face in Faces:
            for i in range(1, len(face.CoordIndex) - 1):
                indexListTemp.append([face.CoordIndex[0], face.CoordIndex[i], face.CoordIndex[i + 1]])

        return indexListTemp

    def parse_geom(self, transform_matrix):
        if (not(self.ifcObject.Representation)):
            return False

        representations = self.ifcObject.Representation.Representations

        listPosition = self.getPosition(self.ifcObject.ObjectPlacement)

        listDirection = self.getDirections(self.ifcObject.ObjectPlacement)

        offset = np.array(transform_matrix[3])
        rotation = np.array(transform_matrix[:-1])

        vertexList = list()
        indexList = list()
        for representation in representations:
            if(representation.RepresentationType == &#34;MappedRepresentation&#34;):
                representation = representation.Items[0].MappingSource.MappedRepresentation

            nb_geom = 0
            for itemGeom in representation.Items:
                nb_geom += 1
                if(nb_geom &gt; 300):
                    continue
                indexListTemp = None
                vertexListTemp = None
                if(representation.RepresentationType == &#34;Tessellation&#34;):
                    if(hasattr(itemGeom, &#39;Faces&#39;)):
                        indexListTemp = self.parse_indexed_faces(itemGeom.Faces)
                    elif (hasattr(itemGeom, &#39;CoordIndex&#39;)):
                        indexListTemp = itemGeom.CoordIndex
                    else:
                        sys.exit(&#34;Géométrie de ce type non encore gérée&#34;)
                    vertexListTemp = itemGeom.Coordinates.CoordList

                elif(representation.RepresentationType == &#34;SweptSolid&#34; and not(itemGeom.is_a(&#34;IfcBooleanClippingResult&#34;))):
                    vertexListTemp, indexListTemp = self.extrudGeom(itemGeom)
                if(vertexListTemp and indexListTemp):
                    for index in indexListTemp:
                        indexList.append([index[0] + len(vertexList), index[1] + len(vertexList), index[2] + len(vertexList)])
                    for vertex in vertexListTemp:
                        vertexList.append(np.array([vertex[0], vertex[1], vertex[2]], dtype=np.float32))

        if (len(indexList) == 0):
            return False

        for j in range(len(vertexList)):
            vertex = vertexList[j]
            for i in range(len(listDirection)):
                vertex = np.dot(np.array(vertex), listDirection[i])
                vertex = (vertex + listPosition[i])

            vertex = vertex * self.convertionRatio
            vertex = np.dot(np.array(vertex), rotation)
            vertex += offset
            vertexList[j] = np.array([round(vertex[0], 5), round(vertex[1], 5), round(vertex[2], 5)], dtype=np.float32)

        triangles = list()
        for index in indexList:
            triangle = []
            for i in range(0, 3):
                # We store each position for each triangles, as GLTF expect
                triangle.append(vertexList[index[i] - 1])
            triangles.append(triangle)

        self.geom.triangles.append(triangles)

        self.set_box()

        return True

    def get_obj_id(self):
        return super().get_id()

    def set_obj_id(self, id):
        return super().set_id(id)


class IfcObjectsGeom(ObjectsToTile):
    &#34;&#34;&#34;
        A decorated list of ObjectsToTile type objects.
    &#34;&#34;&#34;

    def __init__(self, objs=None):
        super().__init__(objs)

    @staticmethod
    def getCentroid(ifcMapConversion):
        location = (ifcMapConversion.Eastings, ifcMapConversion.Northings, ifcMapConversion.OrthogonalHeight)

        centroid = [[0, ifcMapConversion.XAxisAbscissa, 0],
                    [-ifcMapConversion.XAxisOrdinate, 0, 0],
                    [0, 0, 1],
                    [location[0], location[1], location[2]]]
        return centroid

    @staticmethod
    def computeCentroid(ifcSite, unitRatio):
        elevation = ifcSite.RefElevation
        placement = ifcSite.ObjectPlacement.RelativePlacement
        location = placement.Location.Coordinates
        location = (location[0] * unitRatio, location[1] * unitRatio, (location[2] + elevation))

        if(placement.Axis is None):
            axis = [0, 0, 1]
        else:
            axis = placement.Axis.DirectionRatios
        if(placement.RefDirection is None):
            refDirection = [1, 0, 0]
        else:
            refDirection = placement.RefDirection.DirectionRatios

        direction = computeDirection(axis, refDirection)
        centroid = [[direction[0][0], direction[0][1], direction[0][2]],
                    [direction[1][0], direction[1][1], direction[1][2]],
                    [direction[2][0], direction[2][1], direction[2][2]],
                    [location[0], location[1], location[2]]]
        return centroid

    @staticmethod
    def retrievObjByType(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
        &#34;&#34;&#34;
        :param path: a path to a directory

        :return: a list of Obj.
        &#34;&#34;&#34;
        ifc_file = ifcopenshell.open(path_to_file)

        if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
            centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
        else:
            centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
        elements = ifc_file.by_type(&#39;IfcElement&#39;)
        nb_element = str(len(elements))
        print(nb_element + &#34; elements to parse&#34;)
        i = 1
        dictObjByType = dict()
        for element in elements:
            print(&#34;\r&#34; + str(i) + &#34; / &#34; + nb_element, end=&#39;&#39;, flush=True)
            if not(element.is_a() in dictObjByType):
                dictObjByType[element.is_a()] = list()
            obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
            if(obj.hasGeom()):
                dictObjByType[element.is_a()].append(obj)
            i = i + 1

        for key in dictObjByType.keys():
            dictObjByType[key] = IfcObjectsGeom(dictObjByType[key])

        return dictObjByType, centroid

    @staticmethod
    def retrievObjByGroup(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
        &#34;&#34;&#34;
        :param path: a path to a directory

        :return: a list of Obj.
        &#34;&#34;&#34;
        ifc_file = ifcopenshell.open(path_to_file)

        if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
            centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
        else:
            centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
        elements = ifc_file.by_type(&#39;IfcElement&#39;)
        nb_element = str(len(elements))
        print(nb_element + &#34; elements to parse&#34;)

        groups = ifc_file.by_type(&#34;IFCRELASSIGNSTOGROUP&#34;)

        dictObjByGroup = dict()
        for group in groups:
            elements_in_group = list()
            for element in group.RelatedObjects:
                if(element.is_a(&#39;IfcElement&#39;)):
                    elements.remove(element)
                    obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid, group.RelatingGroup.Name)
                    if(obj.hasGeom()):
                        elements_in_group.append(obj)
            dictObjByGroup[group.RelatingGroup.Name] = elements_in_group

        elements_not_in_group = list()
        for element in elements:
            obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
            if(obj.hasGeom()):
                elements_not_in_group.append(obj)
        dictObjByGroup[&#34;None&#34;] = elements_not_in_group

        for key in dictObjByGroup.keys():
            dictObjByGroup[key] = IfcObjectsGeom(dictObjByGroup[key])

        return dictObjByGroup, centroid</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.compute2DDirection"><code class="name flex">
<span>def <span class="ident">compute2DDirection</span></span>(<span>refDirection)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute2DDirection(refDirection):
    return np.array([np.array([refDirection[0], refDirection[1]]), np.array([-refDirection[1], refDirection[0]])])</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.computeDirection"><code class="name flex">
<span>def <span class="ident">computeDirection</span></span>(<span>axis, refDirection)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeDirection(axis, refDirection):
    # ref to https://standards.buildingsmart.org/IFC/RELEASE/IFC2x3/FINAL/HTML/ifcgeometryresource/lexical/ifcfirstprojaxis.htm
    # and https://standards.buildingsmart.org/IFC/RELEASE/IFC2x3/FINAL/HTML/ifcgeometryresource/lexical/ifcbuildaxes.htm
    Z = normalize(axis)
    V = normalize(refDirection)
    XVec = np.multiply(np.dot(V, Z), Z)
    XAxis = normalize(np.subtract(V, XVec))
    return np.array([XAxis, np.cross(Z, XAxis), Z])</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.unitConversion"><code class="name flex">
<span>def <span class="ident">unitConversion</span></span>(<span>originalUnit, targetedUnit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unitConversion(originalUnit, targetedUnit):
    conversions = {
        &#34;mm&#34;: {&#34;mm&#34;: 1, &#34;cm&#34;: 1 / 10, &#34;m&#34;: 1 / 1000, &#34;km&#34;: 1 / 1000000},
        &#34;cm&#34;: {&#34;mm&#34;: 10, &#34;cm&#34;: 1, &#34;m&#34;: 1 / 100, &#34;km&#34;: 1 / 100000},
        &#34;m&#34;: {&#34;mm&#34;: 1000, &#34;cm&#34;: 100, &#34;m&#34;: 1, &#34;km&#34;: 1 / 1000},
        &#34;km&#34;: {&#34;mm&#34;: 100000, &#34;cm&#34;: 10000, &#34;m&#34;: 1000, &#34;km&#34;: 1},
    }
    return conversions[originalUnit][targetedUnit]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom"><code class="flex name class">
<span>class <span class="ident">IfcObjectGeom</span></span>
<span>(</span><span>ifcObject, originalUnit='m', targetedUnit='m', transform_matrix=None, ifcGroup=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class of all object that need to be tiled, in order to be
used with the corresponding tiler.</p>
<p>:param id: given identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IfcObjectGeom(ObjectToTile):
    def __init__(self, ifcObject, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;, transform_matrix=None, ifcGroup=None):
        super().__init__(ifcObject.GlobalId)

        self.ifcObject = ifcObject
        self.setIfcClasse(ifcObject.is_a(), ifcGroup)
        self.convertionRatio = unitConversion(originalUnit, targetedUnit)
        self.has_geom = self.parse_geom(transform_matrix)

    def hasGeom(self):
        return self.has_geom

    def get_geom_as_triangles(self):
        return self.geom.triangles[0]

    def set_triangles(self, triangles):
        self.geom.triangles[0] = triangles

    def computeCenter(self, pointList):
        center = np.array([0.0, 0.0, 0.0])
        for point in pointList:
            center += np.array([point[0], point[1], 0])
        return center / len(pointList)

    def setIfcClasse(self, ifcClasse, ifcGroup):
        self.ifcClasse = ifcClasse
        batch_table_data = {
            &#39;classe&#39;: ifcClasse,
            &#39;group&#39;: ifcGroup
        }
        super().set_batchtable_data(batch_table_data)

    def getIfcClasse(self):
        return self.ifcClasse

    def computePointsFromRectangleProfileDef(self, sweptArea):
        points = list()
        maxX = sweptArea.XDim / 2
        minX = -maxX
        maxY = sweptArea.YDim / 2
        minY = -maxY

        position = sweptArea.Position.Location.Coordinates

        refDirection = [1, 0]

        if (sweptArea.Position.RefDirection):
            refDirection = sweptArea.Position.RefDirection.DirectionRatios

        direction = compute2DDirection(refDirection)

        points.append(np.array([minX, minY]))
        points.append(np.array([minX, maxY]))
        points.append(np.array([maxX, maxY]))
        points.append(np.array([maxX, minY]))
        points.append(points[0])

        for i in range(len(points)):
            points[i] = np.dot(np.array(points[i]), direction) + position
        return points

    def computePointsFromCircleProfileDef(self, sweptArea):
        radius = sweptArea.Radius
        position = sweptArea.Position.Location.Coordinates

        refDirection = [1, 0]

        if (sweptArea.Position.RefDirection):
            refDirection = sweptArea.Position.RefDirection.DirectionRatios

        direction = compute2DDirection(refDirection)

        points = list()
        # The lower this value the higher quality the circle is with more points generated
        stepSize = 0.1
        t = 0
        while t &lt; 2 * math.pi:
            points.append(np.array([radius * math.cos(t), radius * math.sin(t)]))
            t += stepSize
        points.append(points[0])

        for i in range(len(points)):
            points[i] = np.dot(np.array(points[i]), direction) + position
        return points

    def getPointsFromOuterCurve(self, outerCurve):
        if(hasattr(outerCurve, &#39;CoordList&#39;)):
            return outerCurve.CoordList
        else:
            points = list()
            for point in outerCurve:
                coord = point.Coordinates
                points.append(np.array([coord[0], coord[1]]))
            return points

    def extrudGeom(self, geom):
        depth = geom.Depth
        extrudedDirection = geom.ExtrudedDirection.DirectionRatios
        extrudVector = np.multiply(extrudedDirection, depth)

        position = geom.Position.Location.Coordinates

        axis = [0, 0, 1]
        refDirection = [1, 0, 0]

        if (geom.Position.Axis):
            axis = geom.Position.Axis.DirectionRatios

        if (geom.Position.RefDirection):
            refDirection = geom.Position.RefDirection.DirectionRatios

        direction = computeDirection(axis, refDirection)

        if(geom.SweptArea.is_a(&#39;IfcArbitraryClosedProfileDef&#39;)):
            if(hasattr(geom.SweptArea.OuterCurve, &#34;Points&#34;)):
                points = self.getPointsFromOuterCurve(geom.SweptArea.OuterCurve.Points)
            else:
                return None, None
        elif(geom.SweptArea.is_a(&#39;IfcRectangleProfileDef&#39;)):
            points = self.computePointsFromRectangleProfileDef(geom.SweptArea)
        elif(geom.SweptArea.is_a(&#39;IfcCircleProfileDef&#39;)):
            points = self.computePointsFromCircleProfileDef(geom.SweptArea)
        else:
            return None, None

        center = self.computeCenter(points)

        vertexList = list()
        indexList = list()
        for point in points:
            vertexList.append(np.array([point[0], point[1], 0]))
        for point in points:
            vertexList.append(np.array([point[0], point[1], 0]) + extrudVector)
        vertexList.append(center)
        vertexList.append(center + extrudVector)

        for i in range(len(vertexList)):
            vertexList[i] = np.dot(np.array(vertexList[i]), direction) + position

        nb_points = len(points)
        i = 0
        for i in range(nb_points - 1):
            indice = i + 1
            indexList.append([indice, (nb_points * 2) + 1, indice + 1])
            indexList.append([indice + nb_points, indice + nb_points + 1, (nb_points * 2) + 2])

        i = 0
        for i in range(nb_points - 1):
            indice = i + 1
            indexList.append([indice, indice + 1, indice + nb_points])
            indexList.append([indice + 1, indice + nb_points + 1, indice + nb_points])

        return vertexList, indexList

    def getPosition(self, ObjectPlacement):
        listPosition = list()
        position = np.array(ObjectPlacement.RelativePlacement.Location.Coordinates)
        listPosition.append(position)
        placementRelTo = ObjectPlacement.PlacementRelTo

        while (placementRelTo):
            if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
                break
            listPosition.append(np.array(placementRelTo.RelativePlacement.Location.Coordinates))
            placementRelTo = placementRelTo.PlacementRelTo
        return listPosition

    def getDirections(self, ObjectPlacement):
        listDirection = list()
        axis = [0, 0, 1]
        if (ObjectPlacement.RelativePlacement.Axis):
            axis = ObjectPlacement.RelativePlacement.Axis.DirectionRatios

        refDirection = [1, 0, 0]
        if (ObjectPlacement.RelativePlacement.RefDirection):
            refDirection = ObjectPlacement.RelativePlacement.RefDirection.DirectionRatios

        listDirection.append(computeDirection(axis, refDirection))

        placementRelTo = ObjectPlacement.PlacementRelTo

        while (placementRelTo):
            if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
                break
            axis = [0, 0, 1]
            if (placementRelTo.RelativePlacement.Axis):
                axis = placementRelTo.RelativePlacement.Axis.DirectionRatios

            refDirection = [1, 0, 0]
            if (placementRelTo.RelativePlacement.RefDirection):
                refDirection = placementRelTo.RelativePlacement.RefDirection.DirectionRatios

            listDirection.append(computeDirection(axis, refDirection))
            placementRelTo = placementRelTo.PlacementRelTo

        return listDirection

    def getElevation(self):
        elevation = 0
        if(self.ifcObject.ContainedInStructure):
            if(not(self.ifcObject.ContainedInStructure[0].RelatingStructure.is_a(&#34;IfcSpace&#34;))):
                elevation += (self.ifcObject.ContainedInStructure[0].RelatingStructure.Elevation * self.convertionRatio)
        return elevation

    def parse_indexed_faces(self, Faces):
        indexListTemp = list()

        for face in Faces:
            for i in range(1, len(face.CoordIndex) - 1):
                indexListTemp.append([face.CoordIndex[0], face.CoordIndex[i], face.CoordIndex[i + 1]])

        return indexListTemp

    def parse_geom(self, transform_matrix):
        if (not(self.ifcObject.Representation)):
            return False

        representations = self.ifcObject.Representation.Representations

        listPosition = self.getPosition(self.ifcObject.ObjectPlacement)

        listDirection = self.getDirections(self.ifcObject.ObjectPlacement)

        offset = np.array(transform_matrix[3])
        rotation = np.array(transform_matrix[:-1])

        vertexList = list()
        indexList = list()
        for representation in representations:
            if(representation.RepresentationType == &#34;MappedRepresentation&#34;):
                representation = representation.Items[0].MappingSource.MappedRepresentation

            nb_geom = 0
            for itemGeom in representation.Items:
                nb_geom += 1
                if(nb_geom &gt; 300):
                    continue
                indexListTemp = None
                vertexListTemp = None
                if(representation.RepresentationType == &#34;Tessellation&#34;):
                    if(hasattr(itemGeom, &#39;Faces&#39;)):
                        indexListTemp = self.parse_indexed_faces(itemGeom.Faces)
                    elif (hasattr(itemGeom, &#39;CoordIndex&#39;)):
                        indexListTemp = itemGeom.CoordIndex
                    else:
                        sys.exit(&#34;Géométrie de ce type non encore gérée&#34;)
                    vertexListTemp = itemGeom.Coordinates.CoordList

                elif(representation.RepresentationType == &#34;SweptSolid&#34; and not(itemGeom.is_a(&#34;IfcBooleanClippingResult&#34;))):
                    vertexListTemp, indexListTemp = self.extrudGeom(itemGeom)
                if(vertexListTemp and indexListTemp):
                    for index in indexListTemp:
                        indexList.append([index[0] + len(vertexList), index[1] + len(vertexList), index[2] + len(vertexList)])
                    for vertex in vertexListTemp:
                        vertexList.append(np.array([vertex[0], vertex[1], vertex[2]], dtype=np.float32))

        if (len(indexList) == 0):
            return False

        for j in range(len(vertexList)):
            vertex = vertexList[j]
            for i in range(len(listDirection)):
                vertex = np.dot(np.array(vertex), listDirection[i])
                vertex = (vertex + listPosition[i])

            vertex = vertex * self.convertionRatio
            vertex = np.dot(np.array(vertex), rotation)
            vertex += offset
            vertexList[j] = np.array([round(vertex[0], 5), round(vertex[1], 5), round(vertex[2], 5)], dtype=np.float32)

        triangles = list()
        for index in indexList:
            triangle = []
            for i in range(0, 3):
                # We store each position for each triangles, as GLTF expect
                triangle.append(vertexList[index[i] - 1])
            triangles.append(triangle)

        self.geom.triangles.append(triangles)

        self.set_box()

        return True

    def get_obj_id(self):
        return super().get_id()

    def set_obj_id(self, id):
        return super().set_id(id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.object_to_tile.ObjectToTile" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectToTile">ObjectToTile</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computeCenter"><code class="name flex">
<span>def <span class="ident">computeCenter</span></span>(<span>self, pointList)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeCenter(self, pointList):
    center = np.array([0.0, 0.0, 0.0])
    for point in pointList:
        center += np.array([point[0], point[1], 0])
    return center / len(pointList)</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromCircleProfileDef"><code class="name flex">
<span>def <span class="ident">computePointsFromCircleProfileDef</span></span>(<span>self, sweptArea)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computePointsFromCircleProfileDef(self, sweptArea):
    radius = sweptArea.Radius
    position = sweptArea.Position.Location.Coordinates

    refDirection = [1, 0]

    if (sweptArea.Position.RefDirection):
        refDirection = sweptArea.Position.RefDirection.DirectionRatios

    direction = compute2DDirection(refDirection)

    points = list()
    # The lower this value the higher quality the circle is with more points generated
    stepSize = 0.1
    t = 0
    while t &lt; 2 * math.pi:
        points.append(np.array([radius * math.cos(t), radius * math.sin(t)]))
        t += stepSize
    points.append(points[0])

    for i in range(len(points)):
        points[i] = np.dot(np.array(points[i]), direction) + position
    return points</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromRectangleProfileDef"><code class="name flex">
<span>def <span class="ident">computePointsFromRectangleProfileDef</span></span>(<span>self, sweptArea)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computePointsFromRectangleProfileDef(self, sweptArea):
    points = list()
    maxX = sweptArea.XDim / 2
    minX = -maxX
    maxY = sweptArea.YDim / 2
    minY = -maxY

    position = sweptArea.Position.Location.Coordinates

    refDirection = [1, 0]

    if (sweptArea.Position.RefDirection):
        refDirection = sweptArea.Position.RefDirection.DirectionRatios

    direction = compute2DDirection(refDirection)

    points.append(np.array([minX, minY]))
    points.append(np.array([minX, maxY]))
    points.append(np.array([maxX, maxY]))
    points.append(np.array([maxX, minY]))
    points.append(points[0])

    for i in range(len(points)):
        points[i] = np.dot(np.array(points[i]), direction) + position
    return points</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.extrudGeom"><code class="name flex">
<span>def <span class="ident">extrudGeom</span></span>(<span>self, geom)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrudGeom(self, geom):
    depth = geom.Depth
    extrudedDirection = geom.ExtrudedDirection.DirectionRatios
    extrudVector = np.multiply(extrudedDirection, depth)

    position = geom.Position.Location.Coordinates

    axis = [0, 0, 1]
    refDirection = [1, 0, 0]

    if (geom.Position.Axis):
        axis = geom.Position.Axis.DirectionRatios

    if (geom.Position.RefDirection):
        refDirection = geom.Position.RefDirection.DirectionRatios

    direction = computeDirection(axis, refDirection)

    if(geom.SweptArea.is_a(&#39;IfcArbitraryClosedProfileDef&#39;)):
        if(hasattr(geom.SweptArea.OuterCurve, &#34;Points&#34;)):
            points = self.getPointsFromOuterCurve(geom.SweptArea.OuterCurve.Points)
        else:
            return None, None
    elif(geom.SweptArea.is_a(&#39;IfcRectangleProfileDef&#39;)):
        points = self.computePointsFromRectangleProfileDef(geom.SweptArea)
    elif(geom.SweptArea.is_a(&#39;IfcCircleProfileDef&#39;)):
        points = self.computePointsFromCircleProfileDef(geom.SweptArea)
    else:
        return None, None

    center = self.computeCenter(points)

    vertexList = list()
    indexList = list()
    for point in points:
        vertexList.append(np.array([point[0], point[1], 0]))
    for point in points:
        vertexList.append(np.array([point[0], point[1], 0]) + extrudVector)
    vertexList.append(center)
    vertexList.append(center + extrudVector)

    for i in range(len(vertexList)):
        vertexList[i] = np.dot(np.array(vertexList[i]), direction) + position

    nb_points = len(points)
    i = 0
    for i in range(nb_points - 1):
        indice = i + 1
        indexList.append([indice, (nb_points * 2) + 1, indice + 1])
        indexList.append([indice + nb_points, indice + nb_points + 1, (nb_points * 2) + 2])

    i = 0
    for i in range(nb_points - 1):
        indice = i + 1
        indexList.append([indice, indice + 1, indice + nb_points])
        indexList.append([indice + 1, indice + nb_points + 1, indice + nb_points])

    return vertexList, indexList</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getDirections"><code class="name flex">
<span>def <span class="ident">getDirections</span></span>(<span>self, ObjectPlacement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDirections(self, ObjectPlacement):
    listDirection = list()
    axis = [0, 0, 1]
    if (ObjectPlacement.RelativePlacement.Axis):
        axis = ObjectPlacement.RelativePlacement.Axis.DirectionRatios

    refDirection = [1, 0, 0]
    if (ObjectPlacement.RelativePlacement.RefDirection):
        refDirection = ObjectPlacement.RelativePlacement.RefDirection.DirectionRatios

    listDirection.append(computeDirection(axis, refDirection))

    placementRelTo = ObjectPlacement.PlacementRelTo

    while (placementRelTo):
        if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
            break
        axis = [0, 0, 1]
        if (placementRelTo.RelativePlacement.Axis):
            axis = placementRelTo.RelativePlacement.Axis.DirectionRatios

        refDirection = [1, 0, 0]
        if (placementRelTo.RelativePlacement.RefDirection):
            refDirection = placementRelTo.RelativePlacement.RefDirection.DirectionRatios

        listDirection.append(computeDirection(axis, refDirection))
        placementRelTo = placementRelTo.PlacementRelTo

    return listDirection</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getElevation"><code class="name flex">
<span>def <span class="ident">getElevation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getElevation(self):
    elevation = 0
    if(self.ifcObject.ContainedInStructure):
        if(not(self.ifcObject.ContainedInStructure[0].RelatingStructure.is_a(&#34;IfcSpace&#34;))):
            elevation += (self.ifcObject.ContainedInStructure[0].RelatingStructure.Elevation * self.convertionRatio)
    return elevation</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getIfcClasse"><code class="name flex">
<span>def <span class="ident">getIfcClasse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIfcClasse(self):
    return self.ifcClasse</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPointsFromOuterCurve"><code class="name flex">
<span>def <span class="ident">getPointsFromOuterCurve</span></span>(<span>self, outerCurve)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPointsFromOuterCurve(self, outerCurve):
    if(hasattr(outerCurve, &#39;CoordList&#39;)):
        return outerCurve.CoordList
    else:
        points = list()
        for point in outerCurve:
            coord = point.Coordinates
            points.append(np.array([coord[0], coord[1]]))
        return points</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPosition"><code class="name flex">
<span>def <span class="ident">getPosition</span></span>(<span>self, ObjectPlacement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPosition(self, ObjectPlacement):
    listPosition = list()
    position = np.array(ObjectPlacement.RelativePlacement.Location.Coordinates)
    listPosition.append(position)
    placementRelTo = ObjectPlacement.PlacementRelTo

    while (placementRelTo):
        if(placementRelTo.PlacesObject[0].is_a(&#34;IfcSite&#34;)):
            break
        listPosition.append(np.array(placementRelTo.RelativePlacement.Location.Coordinates))
        placementRelTo = placementRelTo.PlacementRelTo
    return listPosition</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_geom_as_triangles"><code class="name flex">
<span>def <span class="ident">get_geom_as_triangles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geom_as_triangles(self):
    return self.geom.triangles[0]</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_obj_id"><code class="name flex">
<span>def <span class="ident">get_obj_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_obj_id(self):
    return super().get_id()</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.hasGeom"><code class="name flex">
<span>def <span class="ident">hasGeom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasGeom(self):
    return self.has_geom</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_geom"><code class="name flex">
<span>def <span class="ident">parse_geom</span></span>(<span>self, transform_matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_geom(self, transform_matrix):
    if (not(self.ifcObject.Representation)):
        return False

    representations = self.ifcObject.Representation.Representations

    listPosition = self.getPosition(self.ifcObject.ObjectPlacement)

    listDirection = self.getDirections(self.ifcObject.ObjectPlacement)

    offset = np.array(transform_matrix[3])
    rotation = np.array(transform_matrix[:-1])

    vertexList = list()
    indexList = list()
    for representation in representations:
        if(representation.RepresentationType == &#34;MappedRepresentation&#34;):
            representation = representation.Items[0].MappingSource.MappedRepresentation

        nb_geom = 0
        for itemGeom in representation.Items:
            nb_geom += 1
            if(nb_geom &gt; 300):
                continue
            indexListTemp = None
            vertexListTemp = None
            if(representation.RepresentationType == &#34;Tessellation&#34;):
                if(hasattr(itemGeom, &#39;Faces&#39;)):
                    indexListTemp = self.parse_indexed_faces(itemGeom.Faces)
                elif (hasattr(itemGeom, &#39;CoordIndex&#39;)):
                    indexListTemp = itemGeom.CoordIndex
                else:
                    sys.exit(&#34;Géométrie de ce type non encore gérée&#34;)
                vertexListTemp = itemGeom.Coordinates.CoordList

            elif(representation.RepresentationType == &#34;SweptSolid&#34; and not(itemGeom.is_a(&#34;IfcBooleanClippingResult&#34;))):
                vertexListTemp, indexListTemp = self.extrudGeom(itemGeom)
            if(vertexListTemp and indexListTemp):
                for index in indexListTemp:
                    indexList.append([index[0] + len(vertexList), index[1] + len(vertexList), index[2] + len(vertexList)])
                for vertex in vertexListTemp:
                    vertexList.append(np.array([vertex[0], vertex[1], vertex[2]], dtype=np.float32))

    if (len(indexList) == 0):
        return False

    for j in range(len(vertexList)):
        vertex = vertexList[j]
        for i in range(len(listDirection)):
            vertex = np.dot(np.array(vertex), listDirection[i])
            vertex = (vertex + listPosition[i])

        vertex = vertex * self.convertionRatio
        vertex = np.dot(np.array(vertex), rotation)
        vertex += offset
        vertexList[j] = np.array([round(vertex[0], 5), round(vertex[1], 5), round(vertex[2], 5)], dtype=np.float32)

    triangles = list()
    for index in indexList:
        triangle = []
        for i in range(0, 3):
            # We store each position for each triangles, as GLTF expect
            triangle.append(vertexList[index[i] - 1])
        triangles.append(triangle)

    self.geom.triangles.append(triangles)

    self.set_box()

    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_indexed_faces"><code class="name flex">
<span>def <span class="ident">parse_indexed_faces</span></span>(<span>self, Faces)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_indexed_faces(self, Faces):
    indexListTemp = list()

    for face in Faces:
        for i in range(1, len(face.CoordIndex) - 1):
            indexListTemp.append([face.CoordIndex[0], face.CoordIndex[i], face.CoordIndex[i + 1]])

    return indexListTemp</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.setIfcClasse"><code class="name flex">
<span>def <span class="ident">setIfcClasse</span></span>(<span>self, ifcClasse, ifcGroup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIfcClasse(self, ifcClasse, ifcGroup):
    self.ifcClasse = ifcClasse
    batch_table_data = {
        &#39;classe&#39;: ifcClasse,
        &#39;group&#39;: ifcGroup
    }
    super().set_batchtable_data(batch_table_data)</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_obj_id"><code class="name flex">
<span>def <span class="ident">set_obj_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_obj_id(self, id):
    return super().set_id(id)</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_triangles"><code class="name flex">
<span>def <span class="ident">set_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_triangles(self, triangles):
    self.geom.triangles[0] = triangles</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.object_to_tile.ObjectToTile" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectToTile">ObjectToTile</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectToTile.set_box" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectToTile.set_box">set_box</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom"><code class="flex name class">
<span>class <span class="ident">IfcObjectsGeom</span></span>
<span>(</span><span>objs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorated list of ObjectsToTile type objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IfcObjectsGeom(ObjectsToTile):
    &#34;&#34;&#34;
        A decorated list of ObjectsToTile type objects.
    &#34;&#34;&#34;

    def __init__(self, objs=None):
        super().__init__(objs)

    @staticmethod
    def getCentroid(ifcMapConversion):
        location = (ifcMapConversion.Eastings, ifcMapConversion.Northings, ifcMapConversion.OrthogonalHeight)

        centroid = [[0, ifcMapConversion.XAxisAbscissa, 0],
                    [-ifcMapConversion.XAxisOrdinate, 0, 0],
                    [0, 0, 1],
                    [location[0], location[1], location[2]]]
        return centroid

    @staticmethod
    def computeCentroid(ifcSite, unitRatio):
        elevation = ifcSite.RefElevation
        placement = ifcSite.ObjectPlacement.RelativePlacement
        location = placement.Location.Coordinates
        location = (location[0] * unitRatio, location[1] * unitRatio, (location[2] + elevation))

        if(placement.Axis is None):
            axis = [0, 0, 1]
        else:
            axis = placement.Axis.DirectionRatios
        if(placement.RefDirection is None):
            refDirection = [1, 0, 0]
        else:
            refDirection = placement.RefDirection.DirectionRatios

        direction = computeDirection(axis, refDirection)
        centroid = [[direction[0][0], direction[0][1], direction[0][2]],
                    [direction[1][0], direction[1][1], direction[1][2]],
                    [direction[2][0], direction[2][1], direction[2][2]],
                    [location[0], location[1], location[2]]]
        return centroid

    @staticmethod
    def retrievObjByType(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
        &#34;&#34;&#34;
        :param path: a path to a directory

        :return: a list of Obj.
        &#34;&#34;&#34;
        ifc_file = ifcopenshell.open(path_to_file)

        if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
            centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
        else:
            centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
        elements = ifc_file.by_type(&#39;IfcElement&#39;)
        nb_element = str(len(elements))
        print(nb_element + &#34; elements to parse&#34;)
        i = 1
        dictObjByType = dict()
        for element in elements:
            print(&#34;\r&#34; + str(i) + &#34; / &#34; + nb_element, end=&#39;&#39;, flush=True)
            if not(element.is_a() in dictObjByType):
                dictObjByType[element.is_a()] = list()
            obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
            if(obj.hasGeom()):
                dictObjByType[element.is_a()].append(obj)
            i = i + 1

        for key in dictObjByType.keys():
            dictObjByType[key] = IfcObjectsGeom(dictObjByType[key])

        return dictObjByType, centroid

    @staticmethod
    def retrievObjByGroup(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
        &#34;&#34;&#34;
        :param path: a path to a directory

        :return: a list of Obj.
        &#34;&#34;&#34;
        ifc_file = ifcopenshell.open(path_to_file)

        if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
            centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
        else:
            centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
        elements = ifc_file.by_type(&#39;IfcElement&#39;)
        nb_element = str(len(elements))
        print(nb_element + &#34; elements to parse&#34;)

        groups = ifc_file.by_type(&#34;IFCRELASSIGNSTOGROUP&#34;)

        dictObjByGroup = dict()
        for group in groups:
            elements_in_group = list()
            for element in group.RelatedObjects:
                if(element.is_a(&#39;IfcElement&#39;)):
                    elements.remove(element)
                    obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid, group.RelatingGroup.Name)
                    if(obj.hasGeom()):
                        elements_in_group.append(obj)
            dictObjByGroup[group.RelatingGroup.Name] = elements_in_group

        elements_not_in_group = list()
        for element in elements:
            obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
            if(obj.hasGeom()):
                elements_not_in_group.append(obj)
        dictObjByGroup[&#34;None&#34;] = elements_not_in_group

        for key in dictObjByGroup.keys():
            dictObjByGroup[key] = IfcObjectsGeom(dictObjByGroup[key])

        return dictObjByGroup, centroid</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.object_to_tile.ObjectsToTile" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile">ObjectsToTile</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.computeCentroid"><code class="name flex">
<span>def <span class="ident">computeCentroid</span></span>(<span>ifcSite, unitRatio)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def computeCentroid(ifcSite, unitRatio):
    elevation = ifcSite.RefElevation
    placement = ifcSite.ObjectPlacement.RelativePlacement
    location = placement.Location.Coordinates
    location = (location[0] * unitRatio, location[1] * unitRatio, (location[2] + elevation))

    if(placement.Axis is None):
        axis = [0, 0, 1]
    else:
        axis = placement.Axis.DirectionRatios
    if(placement.RefDirection is None):
        refDirection = [1, 0, 0]
    else:
        refDirection = placement.RefDirection.DirectionRatios

    direction = computeDirection(axis, refDirection)
    centroid = [[direction[0][0], direction[0][1], direction[0][2]],
                [direction[1][0], direction[1][1], direction[1][2]],
                [direction[2][0], direction[2][1], direction[2][2]],
                [location[0], location[1], location[2]]]
    return centroid</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.getCentroid"><code class="name flex">
<span>def <span class="ident">getCentroid</span></span>(<span>ifcMapConversion)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getCentroid(ifcMapConversion):
    location = (ifcMapConversion.Eastings, ifcMapConversion.Northings, ifcMapConversion.OrthogonalHeight)

    centroid = [[0, ifcMapConversion.XAxisAbscissa, 0],
                [-ifcMapConversion.XAxisOrdinate, 0, 0],
                [0, 0, 1],
                [location[0], location[1], location[2]]]
    return centroid</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByGroup"><code class="name flex">
<span>def <span class="ident">retrievObjByGroup</span></span>(<span>path_to_file, originalUnit='m', targetedUnit='m')</span>
</code></dt>
<dd>
<div class="desc"><p>:param path: a path to a directory</p>
<p>:return: a list of Obj.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def retrievObjByGroup(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
    &#34;&#34;&#34;
    :param path: a path to a directory

    :return: a list of Obj.
    &#34;&#34;&#34;
    ifc_file = ifcopenshell.open(path_to_file)

    if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
        centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
    else:
        centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
    elements = ifc_file.by_type(&#39;IfcElement&#39;)
    nb_element = str(len(elements))
    print(nb_element + &#34; elements to parse&#34;)

    groups = ifc_file.by_type(&#34;IFCRELASSIGNSTOGROUP&#34;)

    dictObjByGroup = dict()
    for group in groups:
        elements_in_group = list()
        for element in group.RelatedObjects:
            if(element.is_a(&#39;IfcElement&#39;)):
                elements.remove(element)
                obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid, group.RelatingGroup.Name)
                if(obj.hasGeom()):
                    elements_in_group.append(obj)
        dictObjByGroup[group.RelatingGroup.Name] = elements_in_group

    elements_not_in_group = list()
    for element in elements:
        obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
        if(obj.hasGeom()):
            elements_not_in_group.append(obj)
    dictObjByGroup[&#34;None&#34;] = elements_not_in_group

    for key in dictObjByGroup.keys():
        dictObjByGroup[key] = IfcObjectsGeom(dictObjByGroup[key])

    return dictObjByGroup, centroid</code></pre>
</details>
</dd>
<dt id="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByType"><code class="name flex">
<span>def <span class="ident">retrievObjByType</span></span>(<span>path_to_file, originalUnit='m', targetedUnit='m')</span>
</code></dt>
<dd>
<div class="desc"><p>:param path: a path to a directory</p>
<p>:return: a list of Obj.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def retrievObjByType(path_to_file, originalUnit=&#34;m&#34;, targetedUnit=&#34;m&#34;):
    &#34;&#34;&#34;
    :param path: a path to a directory

    :return: a list of Obj.
    &#34;&#34;&#34;
    ifc_file = ifcopenshell.open(path_to_file)

    if(ifc_file.by_type(&#34;IfcMapConversion&#34;)):
        centroid = IfcObjectsGeom.getCentroid(ifc_file.by_type(&#34;IfcMapConversion&#34;)[0])
    else:
        centroid = IfcObjectsGeom.computeCentroid(ifc_file.by_type(&#39;IfcSite&#39;)[0], unitConversion(originalUnit, targetedUnit))
    elements = ifc_file.by_type(&#39;IfcElement&#39;)
    nb_element = str(len(elements))
    print(nb_element + &#34; elements to parse&#34;)
    i = 1
    dictObjByType = dict()
    for element in elements:
        print(&#34;\r&#34; + str(i) + &#34; / &#34; + nb_element, end=&#39;&#39;, flush=True)
        if not(element.is_a() in dictObjByType):
            dictObjByType[element.is_a()] = list()
        obj = IfcObjectGeom(element, originalUnit, targetedUnit, centroid)
        if(obj.hasGeom()):
            dictObjByType[element.is_a()].append(obj)
        i = i + 1

    for key in dictObjByType.keys():
        dictObjByType[key] = IfcObjectsGeom(dictObjByType[key])

    return dictObjByType, centroid</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.object_to_tile.ObjectsToTile" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile">ObjectsToTile</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.change_crs" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.change_crs">change_crs</a></code></li>
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.get_centroid" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.get_size" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.get_size">get_size</a></code></li>
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.is_list_of_objects_to_tile" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.is_list_of_objects_to_tile">is_list_of_objects_to_tile</a></code></li>
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.scale_objects" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.scale_objects">scale_objects</a></code></li>
<li><code><a title="py3dtilers.Common.object_to_tile.ObjectsToTile.translate_objects" href="../Common/object_to_tile.html#py3dtilers.Common.object_to_tile.ObjectsToTile.translate_objects">translate_objects</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers.IfcTiler" href="index.html">py3dtilers.IfcTiler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.compute2DDirection" href="#py3dtilers.IfcTiler.ifcObjectGeom.compute2DDirection">compute2DDirection</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.computeDirection" href="#py3dtilers.IfcTiler.ifcObjectGeom.computeDirection">computeDirection</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.normalize" href="#py3dtilers.IfcTiler.ifcObjectGeom.normalize">normalize</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.unitConversion" href="#py3dtilers.IfcTiler.ifcObjectGeom.unitConversion">unitConversion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom">IfcObjectGeom</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computeCenter" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computeCenter">computeCenter</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromCircleProfileDef" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromCircleProfileDef">computePointsFromCircleProfileDef</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromRectangleProfileDef" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.computePointsFromRectangleProfileDef">computePointsFromRectangleProfileDef</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.extrudGeom" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.extrudGeom">extrudGeom</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getDirections" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getDirections">getDirections</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getElevation" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getElevation">getElevation</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getIfcClasse" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getIfcClasse">getIfcClasse</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPointsFromOuterCurve" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPointsFromOuterCurve">getPointsFromOuterCurve</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPosition" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.getPosition">getPosition</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_geom_as_triangles" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_geom_as_triangles">get_geom_as_triangles</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_obj_id" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.get_obj_id">get_obj_id</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.hasGeom" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.hasGeom">hasGeom</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_geom" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_geom">parse_geom</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_indexed_faces" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.parse_indexed_faces">parse_indexed_faces</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.setIfcClasse" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.setIfcClasse">setIfcClasse</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_obj_id" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_obj_id">set_obj_id</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_triangles" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectGeom.set_triangles">set_triangles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom">IfcObjectsGeom</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.computeCentroid" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.computeCentroid">computeCentroid</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.getCentroid" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.getCentroid">getCentroid</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByGroup" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByGroup">retrievObjByGroup</a></code></li>
<li><code><a title="py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByType" href="#py3dtilers.IfcTiler.ifcObjectGeom.IfcObjectsGeom.retrievObjByType">retrievObjByType</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>